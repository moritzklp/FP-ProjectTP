\subsection{Why Haskell}\label{sec:why_haskell}

\paragraph{Compiled and Optimized Execution} Studies have shown that Haskell implementations of cryptographic functions can perform nearly as well as C. 
For example, a Haskell implementation of the CAST-128 cipher ran within the same order of magnitude as an equivalent C version. 
This proves that it can handle computationally intensive cryptographic tasks.

\paragraph{Lazy Evaluation} Haskell uses lazy evaluation, which means that it only computes the values when they are needed.
This can help to improve the efficiency by avoiding unnecessary calculations. 
For our many-time pad attack this would help to handle large ciphertexts efficiently by processing them only when required.
This also helps to reduce the memory usage and computation overhead.

\paragraph{Memory Safety}
Unlike languages like C, Haskell automatically manages the memory, preventing vulnerabilities such as buffer overflows and pointer-related bugs.
This is important in cryptographic applications because small memory errors can lead to security flaws. 
With Haskell we do not have to worry about memory corruption or unexpected behavior due to false memory management.

\paragraph{Strong Type System}
Haskell has a strong type system that ensures that variables hold only correct kinds of values. 
This reduces the programming mistakes such as mixing up data types or performing incorrect calculations on data.
The type system also prevents unintended operations, such as treating a byte array as a string, which could introduce security risks in cryptographic applications.

\paragraph{Immutability}
Haskell's immutability (by default) means that once a value is created, it cannot be changed. 
This prevents unintended modifications of the data during the execution, which can be a problem in other languages where variables can be overwritten accidentally.

\paragraph{Arbitrary Precision Arithmetic}
Haskell allows computations with arbitrary large numbers which prevents the overflow issues that are common in many other languages.
This is useful in cryptographic application where calculations may involve large integers, and unexpected overflows could lead to incorrect results.

\paragraph{Purity}
Haskell's pure functions make sure that the same input always produces the same output, which makes cryptographic computations easier to test and debug. 
Since there are no hidden side effects, cryptographic functions can be verified more easily than in imperative languages.

